\documentclass[a4paper,oneside,12pt]{article}
\usepackage[slovene]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{url}
\usepackage{graphicx}
\usepackage[usenames]{color}
\usepackage[reqno]{amsmath}
\usepackage{amssymb,amsthm,mathabx}
\usepackage{enumerate}
\usepackage{array}
\usepackage[bookmarks, bookmarksopen, bookmarksdepth=3, colorlinks=true,
  linkcolor=black, anchorcolor=black, citecolor=black, filecolor=black,
  menucolor=black, runcolor=black, urlcolor=black, pdfencoding=unicode
]{hyperref}
\usepackage[
  paper=a4paper,
  top=2.5cm,
  bottom=2.5cm,
  textwidth=15cm,
]{geometry}

\usepackage{icomma}
\usepackage{units}
\usepackage{minted}
\usepackage{nameref}

\def\R{\mathbb{R}}
\def\N{\mathbb{N}}
\def\Z{\mathbb{Z}}
\def\C{\mathbb{C}}
\def\Q{\mathbb{Q}}

\newenvironment{itemize*}%
{
\vspace{-6pt}
\begin{itemize}
\setlength{\itemsep}{0pt}
\setlength{\parskip}{2pt}
}
{\end{itemize}}

\newenvironment{description*}%
{
\begin{description}
\setlength{\itemsep}{0pt}
\setlength{\parskip}{2pt}
}
{\end{description}}

\newcommand{\mytitle}{Codebook}
\title{\mytitle}
\author{Jure Slak}
\date{\today}
\hypersetup{pdftitle={\mytitle}}
\hypersetup{pdfauthor={Jure Slak}}
\hypersetup{pdfsubject={}}

\newmintedfile[cppsource]{c++}{linenos=true, mathescape, xleftmargin=0.7cm,
                               fontsize=\scriptsize,baselinestretch=0.9,firstline=3}
\newmintedfile[cppheadersource]{c++}{linenos=true, mathescape, xleftmargin=0.7cm,
                                     fontsize=\scriptsize,baselinestretch=0.9,firstline=6}
\newmintedfile[pysource]{python}{linenos=true, mathescape, xleftmargin=0.7cm,
                                 fontsize=\scriptsize,baselinestretch=0.9}

\newcommand{\cpp}[1]{\cppsource{implementacija/#1}}
\newcommand{\hpp}[1]{\cppheadersource{implementacija/#1}}
\newcommand{\ull}{\texttt{unsigned long long}}

\begin{document}

\thispagestyle{empty}

\vspace*{\fill}
\begin{center}
  \scalebox{6}{\texttt{Codebook}}\\[6ex]
  \scalebox{2}{Pitoni\textbf{++}}\\[4ex]
  Žiga Gosar, Maks Kolman, Jure Slak
  \vfill
  \parbox{0.65\textwidth}{
  \begin{itemize*}
    \item podrobno in pozorno preberi navodila
    \item pazi na \texttt{double} in \ull
    \item počisti podatke med testnimi primeri
    \item uporabi \texttt{cin.sync\_with\_stdio(false);}\\
      \texttt{cin.tie(nullptr);} in nikoli \texttt{endl} za hitrejši IO
    \item uporabi \texttt{numeric\_limits<tip>::max()} \\ ali \texttt{infinity()},
      \texttt{min()} za robne vrednosti
    \item uporabi \texttt{g++ -o ox x.cpp -std=c++11 -Wall -pedantic -Wextra}
    \item v template dodaj
      algorithm,
      array,
      complex,
      cmath,
      functional,
      iostream,
      limits,
      map,
      queue,
      set,
      stack,
      string,
      tuple,
      utility,
      vector,
      namespace std in cin zadeve.
  \end{itemize*}}
  \vfill
  verzija: \today
\end{center}

\newpage

\tableofcontents

\newpage

\section{Grafi}
\label{sec:grafi}

\subsection{Topološko sortiranje}
\begin{description*}
  \item[Vhod:] Usmerjen graf $G$ brez ciklov. $G$ ne sme imeti zank, če pa jih ima, se
    jih lahko brez škode odstrani.
  \item[Izhod:] Topološka ureditev usmerjenega grafa $G$, to je seznam vozlišč v takem
    vrstnem redu, da nobena povezava ne kaže nazaj. Če je vrnjeni seznam krajši
    od $n$, potem ima $G$ cikle.
  \item[Časovna zahtevnost:] $O(V + E)$
  \item[Prostorska zahtevnost:] $O(V + E)$
  \item[Testiranje na terenu:] UVa 10305
\end{description*}
\cpp{grafi/topological_sort.cpp}

\subsection{Najdaljša pot v DAGu}
\begin{description*}
  \item[Vhod:] Usmerjen utežen graf $G$ brez ciklov in vozlišči $s$ in $t$. $G$ ne sme imeti zank, če pa jih ima, se
    jih lahko brez škode odstrani.
  \item[Izhod:] Dolžino najdaljše poti med $s$ in $t$, oz.\ $-1$, če ta pot ne
    obstaja. Z lahkoto najdemo tudi dejansko pot (shranjujemo predhodnika) ali
    najkrajšo pot (max $\to$ min).
  \item[Časovna zahtevnost:] $O(V + E)$
  \item[Prostorska zahtevnost:] $O(V + E)$
  \item[Testiranje na terenu:] UVa 103
\end{description*}
\cpp{grafi/longest_path_in_a_dag.cpp}

\subsection{Mostovi in prerezna vozlišča grafa}
\label{sec:bridge}
\begin{description*}
  \item[Vhod:] Število vozlišč $n$ in število povezav $m$ ter seznam povezav $E$
    oblike $u \to v$ dolžine $m$. Neusmerjen graf $G$ je tako sestavljen iz vozlišč z oznakami
    0 do $n-1$ in povezavami iz $E$.
  \item[Izhod:] Seznam prereznih vozlišč: točk, pri katerih, če jih
    odstranimo, graf razpade na dve komponenti in seznam mostov grafa $G$: povezav, pri
    katerih, če jih odstranimo, graf razpade na dve komponenti.
  \item[Časovna zahtevnost:] $O(V + E)$
  \item[Prostorska zahtevnost:] $O(V + E)$
  \item[Testiranje na terenu:] UVa 315
\end{description*}
\cpp{grafi/articulation_points_and_bridges.cpp}

\subsection{Močno povezane komponente}
\label{sec:scc}
\begin{description*}
  \item[Vhod:] Seznam sosednosti s težami povezav.
  \item[Izhod:] Seznam povezanih komponent grafa v obratni topološki ureditvi in
    kvocientni graf, to je DAG, ki ga dobimo iz grafa, če njegove komponente
    stisnemo v točke. Morebitnih več povezav med dvema komponentama seštejemo.
  \item[Časovna zahtevnost:] $O(V + E)$
  \item[Prostorska zahtevnost:] $O(V + E)$
  \item[Testiranje na terenu:]
    \url{http://putka.upm.si/tasks/2012/2012_3kolo/zakladi}
\end{description*}
\cpp{grafi/strongly_connected_components.cpp}

\subsection{Najkrajša pot v grafu}

\subsubsection{Dijkstra}
\label{sec:dijkstra}
\begin{description*}
  \item[Vhod:] Seznam sosednosti s težami povezav in dve točki grafa. Povezave
    morajo biti pozitivne.
  \item[Izhod:] Dolžina najkrajša poti od prve do druge točke. Z lahkoto vrne
    tudi pot, glej kvadratično verzijo za implementacijo.
  \item[Časovna zahtevnost:] $O(E\log(E))$
  \item[Prostorska zahtevnost:] $O(V + E)$
  \item[Testiranje na terenu:]
    \url{http://putka.upm.si/tasks/2013/2013_1kolo/wolowitz}
\end{description*}
\cpp{grafi/dijkstra.cpp}

\subsubsection{Dijkstra (kvadratičen)}
\label{sec:dijkstra-square}
\begin{description*}
  \item[Vhod:] Seznam sosednosti s težami povezav in dve točki grafa. Povezave
    morajo biti pozitivne.
  \item[Izhod:] Najkrajša pot med danima točkama, dana kot seznam vmesnih
    vozlišč skupaj z obema krajiščema.
  \item[Časovna zahtevnost:] $O(V^2)$, to je lahko bolje kot $O(E\log(E))$.
  \item[Prostorska zahtevnost:] $O(V + E)$
  \item[Testiranje na terenu:]
    \url{http://putka.upm.si/tasks/2013/2013_1kolo/wolowitz}
\end{description*}
\cpp{grafi/dijkstra_square.cpp}

\subsubsection{Bellman-Ford}
\label{sec:bellman-ford}
\begin{description*}
  \item[Vhod:] Seznam sosednosti s težami povezav in točka grafa. Povezave
    ne smejo imeti negativnega cikla (duh).
  \item[Izhod:] Vrne razdaljo od dane točke do vseh drugih. Ni nič ceneje če
    iščemo samo do določene točke.
  \item[Časovna zahtevnost:] $O(EV)$
  \item[Prostorska zahtevnost:] $O(V + E)$
  \item[Testiranje na terenu:]
    \url{http://putka.upm.si/tasks/2013/2013_1kolo/wolowitz}
\end{description*}
\cpp{grafi/bellman_ford.cpp}

\subsubsection{Floyd-Warhsall}
\label{sec:floyd-warshall}
\begin{description*}
  \item[Vhod:] Število vozlišč, število povezav in seznam povezav. Povezave
    ne smejo imeti negativnega cikla (duh).
  \item[Izhod:] Vrne matriko razdalj med vsemi točkami, $d[i][j]$ je razdalja
    od $i$-te do $j$-te točke. Če je katerikoli diagonalen element negativen,
    ima graf negativen cikel. Rekonstrukcija poti je možna s pomočjo dodatne
    tabele, kjer hranimo naslednika.
  \item[Časovna zahtevnost:] $O(V^3)$, dober za goste grafe.
  \item[Prostorska zahtevnost:] $O(V^2)$
  \item[Testiranje na terenu:]
    \url{http://putka.upm.si/tasks/2013/2013_1kolo/wolowitz}
\end{description*}
\cpp{grafi/floyd_warshall.cpp}

\subsection{Minimalno vpeto drevo}
\label{sec:mst}

\subsubsection{Prim}
\label{sec:mst-prim}
\begin{description*}
  \item[Vhod:] Neusmerjen povezan graf s poljubnimi cenami povezav.
  \item[Izhod:] Vrne ceno najmanjšega vpetega drevesa. Z lahkoto to zamenjamo z
    maksimalnim (ali katerokoli podobno operacijo) drevesom.
  \item[Časovna zahtevnost:] $O(E\log(E))$, dober za goste grafe.
  \item[Prostorska zahtevnost:] $O(V + E)$
  \item[Testiranje na terenu:] UVa 11631
\end{description*}
\cpp{grafi/prim_minimal_spanning_tree.cpp}

\subsubsection{Kruskal}
\label{sec:mst-kruskal}
\begin{description*}
  \item[Vhod:] Neusmerjen povezan graf s poljubnimi cenami povezav.
  \item[Izhod:] Vrne ceno najmanjšega vpetega drevesa. Z lahkoto to zamenjamo z
    maksimalnim (ali katerokoli podobno operacijo) drevesom.
  \item[Časovna zahtevnost:] $O(E\log(E))$, dober za redke grafe. Če so povezave
    že sortirane, samo $O(E \alpha(V))$.
  \item[Prostorska zahtevnost:] $O(V + E)$
  \item[Testiranje na terenu:] UVa 11631
\end{description*}
\cpp{grafi/kruskal_minimal_spanning_tree.cpp}

\subsection{Najnižji skupni prednik}
\label{sec:lca}
\begin{description*}
  \item[Vhod:] Drevo, podano s tabelo staršev. Vozlišče je koren, če je starš
    samemu sebi. Za queryje najprej potrebuješ pomožno tabelo skokov na višja
    vozlišča in tabelo nivojev.
  \item[Izhod:] Za dani vozlišči $u$ in $v$, vrne njunega najnižjega skupnega
    prednika, to je tako vozlišče $p$, da je $p$ leži na poti od $u$ do korena
    in od $v$ do korena, ter je najdlje stran od korena drevesa.
  \item[Časovna zahtevnost:] $O(\log(n))$ na query, s $O(n\log(n))$
    predprocesiranja.
  \item[Prostorska zahtevnost:] $O(n\log(n))$
  \item[Testiranje na terenu:] \url{http://www.spoj.com/submit/LCA/}
\end{description*}
\cpp{grafi/lowest_common_ancestor.cpp}

\subsection{Največji pretok in najmanjši prerez}
\label{sec:maxflow}

\subsubsection{Edmonds-Karp}
\label{sec:maxflow-edmonds-karp}
\begin{description*}
  \item[Vhod:] Matrika kapacitet, vse morajo biti nenegativne.
  \item[Izhod:] Vrne maksimalen pretok, ki je enak minimalnemu prerezu.
    Konstruira tudi matriko pretoka.
  \item[Časovna zahtevnost:] $O(V E^2)$
  \item[Prostorska zahtevnost:] $O(V^2)$
  \item[Testiranje na terenu:] UVa 820
\end{description*}
\cpp{grafi/edmonds_karp_maximal_flow.cpp}

\subsection{Največje prirejanje in najmanjše pokritje}
\label{sec:mbm}
V angleščini: \emph{maximum cardinality bipartite matching} (če bi dodali še
kakšno povezavo bi se dve stikali) in \emph{minimum vertex cover} (če bi vzeli
še kakšno točko stran, bi bila neka povezava brez pobarvane točke na obeh
koncih).
\begin{description*}
  \item[Vhod:] Dvodelen neutežen graf, dan s seznamom sosedov. Prvih \texttt{left} vozlišč je na
    levi strani.
  \item[Izhod:] Število povezav v $MCBM$ = število točk v $MVC$, prvi $MVC$ vrne tudi neko minimalno
    pokritje. Velja tudi $MIS = V - MCBM$, $MIS$ pomeni \emph{maximum
    independent set}.
  \item[Časovna zahtevnost:] $O(VE)$
  \item[Prostorska zahtevnost:] $O(V + E)$
  \item[Testiranje na terenu:] UVa 11138
\end{description*}
\cpp{grafi/bipartite_matching.cpp}

\section{Podatkovne strukture}
\label{sec:ps}

\subsection{Statično binarno iskalno drevo}
\label{sec:bst}
\begin{description*}
  \item[Operacije:] Klasično uravnoteženo binarno iskalno drevo.
    \begin{itemize*}
      \item vstavi: doda +1 k countu na mestu \texttt{idx}
      \item briši: vrne \verb|true|/\verb|false| glede na to ali element
        obstaja in če, zmanjša njegov count za 1
      \item najdi $k$-tega: vrne indeks $k$-tega elementa. Zero based.
    \end{itemize*}
  \item[Časovna zahtevnost:] $O(\log(n))$ na operacijo
  \item[Prostorska zahtevnost:] $O(n)$
  \item[Testiranje na terenu:]
    \url{http://putka.upm.si/tasks/2011/2011_finale/kitajci}
\end{description*}
\cpp{ps/static_binary_search_tree.cpp}

\subsection{Drevo segmentov}
\label{sec:segment-tree}
\begin{description*}
  \item[Operacije:] Segment tree deljen po fiksnih točkah z dinamično alokacijo
    node-ov. Ob ustvarjanju roota povemo razpon vstavljanja, končne točke so
    postavljene po celih številih.

    Za remove, ki ne zagotavlja nujno, da obstajajo stvari ki jih
    brišemo, se je treba malo bolj potruditi. Najprej odstranimo vse na
    trenutnem levelu, kolikor lahko, nato pa se v vsakem primeru pokličemo
    dalje (če je še kaj za odstranit in node-i obstajajo). Prav tako lahko
    vrnemo število izbrisanih stvari.
    \begin{itemize*}
      \item vstavi neko vrednost na intervalu $[a, b]$
      \item briši na intervalu $[a, b]$
      \item dobi vrednost na intervalu $[a, b]$
      \item najdi $k$-tega
    \end{itemize*}
  \item[Časovna zahtevnost:] $O(\log(n))$ na operacijo
  \item[Prostorska zahtevnost:] $O(n)$
  \item[Testiranje na terenu:] \url{http://putka.upm.si/competitions/upm2014-finale/izstevanka}
\end{description*}
\hpp{ps/segment_tree.h}

\subsection{Avl drevo}
\label{sec:avl}
\begin{description*}
  \item[Operacije:] Klasično uravnoteženo binarno iskalno drevo.
    \begin{itemize*}
      \item vstavi: doda +1 k countu, če obstaja
      \item najdi: vrne pointer na node ali \verb|nullptr|, če ne obstaja
      \item briši: vrne \verb|true|/\verb|false| glede na to ali element
        obstaja in samo zmanjša njegov count (memory overhead, ampak who cares)
      \item najdi $n$-tega, vrne \verb|nullptr| če ne obstaja
    \end{itemize*}
  \item[Časovna zahtevnost:] $O(\log(n))$ na operacijo
  \item[Prostorska zahtevnost:] $O(n)$
  \item[Testiranje na
    terenu:]\url{http://putka.upm.si/competitions/upm2014-finale/izstevanka}
  \item[Opombe:] To je lepa implementacija. V praksi ne rabimo vsega public
    interface-a je dovolj samo imeti nekje globalen root in private metode.
\end{description*}
\hpp{ps/avl_tree.h}

\subsection{Fenwickovo drevo}
\label{sec:fenwick}
\begin{description*}
  \item[Operacije:] Imamo tabelo z indeksi $1 \leq x \leq 2^k$ v kateri
    hranimo števila. Želimo hitro posodabljati elemente in odgovarjati na queryje
    po vsoti podseznamov.
    \begin{itemize*}
      \item preberi vsoto do indeksa $x$ (za poljuben podseznam, $read(b) - read(a)$)
      \item posodobi število na indeksu $x$
      \item preberi število na indeksu $x$.
    \end{itemize*}
  \item[Časovna zahtevnost:] $O(k)$ na operacijo
  \item[Prostorska zahtevnost:] $O(2^k)$
  \item[Testiranje na terenu:]\url{http://putka.upm.si/competitions/upm2013-finale/safety}
\end{description*}
\cpp{ps/fenwick_tree.cpp}

\subsection{Fenwickovo drevo ($\mathbf n$-dim)}
\label{sec:fenwick-nd}
\begin{description*}
  \item[Operacije:] Imamo $n$-dim tabelo dimenzij $d_1 \times d_2 \times
    \dots \times d_n$ z
    zero-based indeksi v kateri hranimo števila.
    Želimo hitro posodabljati elemente in odgovarjati na queryje
    po vsoti podkvadrov.
    \begin{itemize*}
      \item preberi vsoto do vključno indeksa $\underline{x}$
      \item posodobi število na indeksu $\underline{x}$
      \item preberi vsoto na podkvadru (pravilo vključitev in izključitev)
    \end{itemize*}
    Funkcije so napisane za 3D, samo dodaj ali odstrani for zanke za višje /
    nižje dimenzije in na ne kockasto tabelo.
  \item[Časovna zahtevnost:] kumulativna vsota in update $O(\log(d_1 + \dots +
    d_n))$, za vsoto podkvadra $O(2^d\log(d_1+\dots+d_n))$.
  \item[Prostorska zahtevnost:] $O(d_1\cdots d_n)$
  \item[Testiranje na terenu:]\url{http://putka.upm.si/tasks/2010/2010_3kolo/stanovanja}
\end{description*}
\cpp{ps/fenwick_tree_nd.cpp}

\subsection{Trie}
\label{sec:trie}
\begin{description*}
  \item[Operacije:] Prefix tree, hranimo besede, crko po crko na nivoju.
    \begin{itemize*}
      \item vstavi besedo
      \item največji skupen prefix z dano besedo
      \item največji skupen prefix med besedami v drevesu (vrne ena preveč)
    \end{itemize*}
  \item[Časovna zahtevnost:] $O(w)$ za \verb|add| in \verb|common_prefix| ter
    $O(\#nodes)$ za najdaljši prefix med vsemi besedami.
  \item[Prostorska zahtevnost:] $O(n w)$, kjer je $n$ število besed, v praksi
    manj, ker se prekrivajo.
  \item[Testiranje na terenu:] \url{http://www.spoj.com/problems/PRHYME/} TODO
\end{description*}
\hpp{ps/trie.h}

\section{Algoritmi}
\label{sec:algo}

\subsection{Najdaljše skupno podzaporedje}
\label{sec:lcs}
\begin{description*}
  \item[Vhod:] Dve zaporedji $a$ in $b$ dolžin $n$ in $m$.
  \item[Izhod:] Najdaljše skupno podzaporedje (ne nujno strnjeno) $LCS$. Lahko dobimo
    samo njegovo dolžino. Problem je povezan z najkrajšim skupnim nadzaporedjem
    ($SCS$). Velja $SCS + LCS = n + m$.
  \item[Časovna zahtevnost:] $O(nm)$
  \item[Prostorska zahtevnost:] $O(nm)$ za podzaporedje, $O(m)$ za dolžino.
  \item[Testiranje na terenu:] UVa 10405
\end{description*}
\cpp{algo/longest_common_subsequence.cpp}

\subsection{Najdaljše naraščajoče podzaporedje}
\label{sec:lis}
\begin{description*}
  \item[Vhod:] Zaporedje elementov na katerih imamo linearno urejenost.
  \item[Izhod:] Najdaljše naraščajoče podzaporedje.
  \item[Časovna zahtevnost:] $O(n \log(n))$ in $O(n^2)$
  \item[Prostorska zahtevnost:] $O(n)$
  \item[Testiranje na terenu:] UVa 103
  \item[Opomba:] Za hitro verzijo je zaradi bisekcije potrebna linearna
    urejenost elementov. Pri $n^2$ verziji je dovolj delna urejenost. V tem primeru je
    elemente morda treba urediti, tako da je potem potrebno za urejanje izbrati
    neko linearno razširitev dane delne urejenosti. Pri obeh verzijah elementi
    niso omejeni na števila, vendar pri prvi ne moremo samo zamenjati tipa, ki
    ga funkcija vrača, lažje je spremeniti, da vrača indekse elementov namesto
    dejanskega zaporedja.
\end{description*}
\cpp{algo/longest_increasing_subsequence.cpp}

\subsection{Najdaljši strnjen palindrom}
\label{sec:max-palindrome}
\begin{description*}
  \item[Vhod:] Niz $s$ dolžine $n$.
  \item[Izhod:] Števili $f$ in $t$, tako da je niz $s[f:t]$ palindrom največje
    dolžine, ki ga je možno najti v $s$. No nujno edini, niti prvi. Uporablja
    Mancherjev algoritem.
  \item[Časovna zahtevnost:] $O(n)$
  \item[Prostorska zahtevnost:] $O(n)$
  \item[Testiranje na terenu:] \url{http://www.spoj.com/problems/LPS/}
\end{description*}
\cpp{algo/longest_palindrome.cpp}

\subsection{Podseznam z največjo vsoto}
\label{sec:max-subarray}
\begin{description*}
  \item[Vhod:] Zaporedje elementov $a_i$ dolžine $n$.
  \item[Izhod:] Največja možna vsota strnjenega podzaporedja $a$ (lahko je tudi
    prazno). Alternativna verzija tudi vrne iskano zaporedje (najkrajše tako).
    Tretja verzija poišče $k$-to največjo vsoto.
  \item[Časovna zahtevnost:] $O(n)$, $O(n\log(n)+nk)$
  \item[Prostorska zahtevnost:] $O(n)$
  \item[Testiranje na terenu:] \url{http://www.codechef.com/problems/KSUBSUM}
\end{description*}
\cpp{algo/maximum_subarray.cpp}

\subsection{Leksikografsko minimalna rotacija}
\label{sec:min-rotation}
\begin{description*}
  \item[Vhod:] Niz znakov $s$ dolžine $n$.
  \item[Izhod:] Indeks $i$, tako da je string $s[i:] + s[:i]$ leksikografsko
    najmanjši, izmed vseh možnih rotacij $s$.
  \item[Časovna zahtevnost:] $O(n)$
  \item[Prostorska zahtevnost:] $O(n)$
  \item[Testiranje na terenu:] UVa 719
  \item[Opomba:] Če smo res na tesnem s prostorom, lahko funkcija sprejme
    dejanski string in ga ne podvoji, ter dela vse indekse po modulu $n$.
\end{description*}
\cpp{algo/minimal_rotation.cpp}

\subsection{BigInt in Karatsuba}
\label{sec:bigint}
Class za računanje z velikimi števili, v poljubni bazi. IO deluje samo v
desetiški.
\begin{description*}
  \item[Operacije:] Seštevanje, odštevanje, množenje, primerjanje.
    \begin{itemize*}
      \item seštevanje: samostojno, za negativne rabi $-$ in $<$.
      \item odštevanje: samostojno, če bo razlika pozitivna. Za negativne
        prevedi na seštevanje $a + (-b)$.
      \item množenje: rabi $+$, $\ll$ in $*$ s števko. Za negativne samo malo
        manipulacije predznakov. Lahko uporabiš tudi karatsubo.
      \item primerjanje: samostojno, za negativne samo malo manipulacije
        predznakov.
    \end{itemize*}
  Jasno ni treba implementirati vsega. $+$ in $*$ nista tako zelo počasna, tako
  da verzije $+=$ ipd. niso nujno potrebne.
  \item[Časovna zahtevnost:] $O(n)$ za $+$, $-$, $*$ stevka, $O(n^2)$ za $*$,
    $O(n^{1.585})$ za karatsubo.
  \item[Prostorska zahtevnost:] $O(n)$
  \item[Testiranje na terenu:]
    \url{http://putka.upm.si/tasks/test_okolja/odstevanje} in
    \url{http://putka.upm.si/tasks/test_okolja/sestevanje}
\end{description*}
\hpp{algo/bigint.h}

\section{Teorija števil}
\label{sec:ts}

\subsection{Evklidov algoritem}
\label{sec:ts:evk}

\begin{description*}
  \item[Vhod:] $a, b \in \Z$
  \item[Izhod:] Največji skupni delitelj $a$ in $b$. Za pozitivna števila je
    pozitiven, če je eno število 0, je rezultat drugo število, pri negativnih je
    predznak odvisen od števila iteracij.
  \item[Časovna zahtevnost:] $O(\log(a) + \log(b))$
  \item[Prostorska zahtevnost:] $O(1)$
\end{description*}
\cpp{ts/gcd.cpp}

\subsection{Razširjen Evklidov algoritem}
\label{sec:ts:extevk}
\begin{description*}
  \item[Vhod:] $a, b \in \Z$. Števili $retx$, $rety$ sta parametra samo za vračanje vrednosti.
  \item[Izhod:] Števila $x, y, d$, pri čemer $d = \gcd(a, b)$, ki rešijo
    Diofantsko enačbo $ax + by = d$. V posebnem primeru, da je $b$ tuj $a$, je
    $x$ inverz števila $a$ v multiplikativni grupi $Z_b^\ast$.
  \item[Časovna zahtevnost:] $O(\log(a) + \log(b))$
  \item[Prostorska zahtevnost:] $O(1)$
  \item[Testiranje na terenu:] UVa 756
\end{description*}
\cpp{ts/extended_gcd.cpp}

\subsection{Kitajski izrek o ostankih}
\label{sec:ts:mod}
\begin{description*}
  \item[Vhod:] Sistem $n$ kongruenc $x \equiv a_i \pmod{m_i}$, $m_i$ so paroma tuji.
  \item[Izhod:] Število $x$, ki reši ta sistem dobimo po formuli
    \[ x =
      \left[\sum_{i=1}^na_i\frac{M}{m_i}\left[\left(\frac{M}{mi}\right)^{-1}\right]_{m_i}\right]_M,
      \qquad M = \prod_{i=1}^nm_i,
    \]
    kjer $[x^{-1}]_m$ označuje inverz $x$ po modulu $m$. Vrnjeni $x$ je med 0 in $M$.
  \item[Časovna zahtevnost:] $O(n \log(\max\{m_i, a_i\}))$
  \item[Prostorska zahtevnost:] $O(n)$
  \item[Potrebuje:] \nameref{sec:ts:evk} (str.~\pageref{sec:ts:evk})
  \item[Testiranje na terenu:] UVa 756
  \item[Opomba:] Pogosto potrebujemo \ull{} namesto \texttt{int}.
\end{description*}
\cpp{ts/chinese_reminder_theorem.cpp}

\subsection{Hitro potenciranje}
\label{sec:fastpow}
\begin{description*}
  \item[Vhod:] Število $g$ iz splošne grupe in $n \in \N_0$.
  \item[Izhod:] Število $g^n$.
  \item[Časovna zahtevnost:] $O(\log(n))$
  \item[Prostorska zahtevnost:] $O(1)$
  \item[Testiranje na terenu:] \url{http://putka.upm.si/tasks/2010/2010_3kolo/nicle}
\end{description*}
\cpp{ts/fast_power.cpp}

\subsection{Številski sestavi}
\label{sec:sestavi}
\begin{description*}
  \item[Vhod:] Število $n \in \N_0$ ali $\frac{p}{q} \in Q$ ter $b \in [2,
      \infty) \cap \N.$
  \item[Izhod:] Število $n$ ali $\frac{p}{q}$ predstavljeno v izbranem sestavu
    z izbranimi števkami in označeno periodo.
  \item[Časovna zahtevnost:] $O(\log(n))$ ali $O(q\log(q))$
  \item[Prostorska zahtevnost:] $O(n)$ ali $O(q)$
  \item[Testiranje na terenu:]
    \url{http://putka.upm.si/tasks/2010/2010_finale/ulomki}
  \item[Opomba:] Zgornja meja za bazo $b$ je dolžina niza
    \verb|STEVILSKI_SESTAVI_ZNAKI|.
\end{description*}
\cpp{ts/stevilski_sestavi.cpp}

\subsection{Eulerjeva funkcija $\phi$}
\label{sec:phi}
\begin{description*}
  \item[Vhod:] Število $n \in \N$.
  \item[Izhod:] Število $\phi(n)$, to je število števil manjših ali enakih $n$ in tujih $n$.
    Direktna formula:
    \[ \phi(n) = n\cdot \prod_{p \divides n}(1-\frac{1}{p}) \]
  \item[Časovna zahtevnost:] $O(\sqrt{n})$
  \item[Prostorska zahtevnost:] $O(1)$
  \item[Testiranje na terenu:]
    \url{https://projecteuler.net/problem=69}
\end{description*}
\cpp{ts/euler_phi.cpp}

\subsection{Eratostenovo rešeto}
\label{sec:primes}
\begin{description*}
  \item[Vhod:] Število $n \in \N$.
  \item[Izhod:] Seznam praštevil manjših od $n$ in seznam, kjer je za vsako
    število manjše od $n$ notri njegov najmanjši praštevilski delitelj. To se
    lahko uporablja za faktorizacijo števil in testiranje praštevilskosti.
  \item[Časovna zahtevnost:] $O(n\log(n))$
  \item[Prostorska zahtevnost:] $O(n)$
  \item[Testiranje na terenu:] UVa 10394
\end{description*}
\cpp{ts/eratosthenes_sieve.cpp}

\subsection{Število deliteljev}
\label{sec:tau}
\begin{description*}
  \item[Vhod:] Število $n \in \N$.
  \item[Izhod:] Število pozitivnih deliteljev $n$, $\tau(n)$. Velja da za $n =
    p_1^{\alpha_1}\cdots p_k^{\alpha_k}$, je \[ \tau(n) = (\alpha_1 + 1) \cdots
    (\alpha_k + 1). \]
  \item[Časovna zahtevnost:] $O(\sqrt(n))$
  \item[Prostorska zahtevnost:] $O(1)$
  \item[Testiranje na terenu:] \url{https://projecteuler.net/problem=12}
\end{description*}
\cpp{ts/number_of_divisors.cpp}

\subsection{Binomski koeficienti}
\label{sec:binom}
\begin{description*}
  \item[Vhod:] Števili $n, k \in \Z$.
  \item[Izhod:] Binomski koeficient $\binom{n}{k} =
    \begin{cases}
      \frac{n!}{k!(n-k)!} & n, k \geq 0 \\
      0 & \text{ sicer}
    \end{cases}$ \\
    Za velike vrednosti lahko izračunamo aproksimacijo s pomočjo logaritma gama
    funkcije.
  \item[Časovna zahtevnost:] $O(\min\{k, n-k\})$
  \item[Prostorska zahtevnost:] $O(1)$
  \item[Testiranje na terenu:] TODO
\end{description*}
\cpp{ts/binomial.cpp}

\section{Geometrija}
\label{sec:geom}
Zaenkrat obravnavamo samo ravninsko geometrijo.
Točke predstavimo kot kompleksna števila. Daljice predstavimo z začetno in
končno točko. Premice s koeficienti v enačbi $ax + by = c$. Premico lahko
konstruiramo iz dveh točk in po želji hranimo točko in smerni vektor.
Pravokotnike predstavimo z spodnjim levim in zgornjim desnim ogliščem.
Večkotnike predstavimo s seznamom točk, kot si sledijo, prve točke ne
ponavljamo. Tip \texttt{ITYPE} predstavlja različne vrste presečišč ali
vsebovanosti: \texttt{OK} pomeni, da se lepo seka oz.\ je točka v notranjosti.
\texttt{NO} pomeni, da se ne seka oz.\ da točna ni vsebovana, \texttt{EQ} pa
pomeni, da se premici prekrivata, daljici sekata v krajišču ali se pokrivata,
oz.\ da je točka na robu.

\subsection{Osnove}
\label{sec:basic}
Funkcije:
\begin{itemize*}
  \item skalarni in vektorski produkt
  \item pravokotni vektor in polarni kot
  \item ploščina trikotnika in enostavnega mnogokotnika
  \item razred za premice
  \item razdalja do premice, daljice, po sferi
  \item vsebovanost v trikotniku, pravokotniku, enostavnem mnogokotniku
  \item presek dveh premic, premice in daljice in dveh daljic
  \item konstrukcije krogov iz treh točk, iz dveh točk in radija
\end{itemize*}
\begin{description*}
  \item[Vhod:] Pri argumentih funkcij.
  \item[Izhod:] Pri argumentih funkcij.
  \item[Časovna zahtevnost:] $O(\text{št.\ točk})$
  \item[Prostorska zahtevnost:] $O(\text{št.\ točk})$
  \item[Testiranje na terenu:] Bolj tako, ima pa obsežne unit teste\dots
\end{description*}
\hpp{geom/basics.h}
\cpp{geom/basics.cpp}

\subsection{Konveksna ovojnica}
\label{sec:convex-hull}
\begin{description*}
  \item[Vhod:] Seznam $n$ točk.
  \item[Izhod:] Najkrajši seznam $h$ točk, ki napenjajo konveksno ovojnico,
    urejen naraščajoče po kotu glede na spodnjo levo točko.
  \item[Časovna zahtevnost:] $O(n\log n)$, zaradi sortiranja
  \item[Prostorska zahtevnost:] $O(n)$
  \item[Potrebuje:] Vektorski produkt, str.~\pageref{sec:basic}.
  \item[Testiranje na terenu:] UVa 681
\end{description*}
\cpp{geom/convex_hull.cpp}

\subsection{Ploščina unije pravokotnikov}
\begin{description*}
  \item[Vhod:] Seznam $n$ pravokotnikov $P_i$ danih s spodnjo levo in zgornjo desno
    točko.
  \item[Izhod:] Ploščina unije danih pravokotnikov.
  \item[Časovna zahtevnost:] $O(n\log n)$
  \item[Prostorska zahtevnost:] $O(n)$
  \item[Testiranje na terenu:] \url{http://putka.upm.si/competitions/upm2013-2/kolaz}
\end{description*}
\cpp{geom/rectangle_union_area.cpp}

\subsection{Najbližji par točk v ravnini}
\begin{description*}
  \item[Vhod:] Seznam $n \geq 2$ točk v ravnini.
  \item[Izhod:] Kvadrat razdalje med najbližjima točkama. Z lahkoto se
    prilagodi, da vrne tudi točki.
  \item[Časovna zahtevnost:] $O(n\log n)$, nisem sure\dots
  :\item[Prostorska zahtevnost:] $O(n \log n)$
  \item[Testiranje na terenu:] UVa 10245
\end{description*}
\cpp{geom/closest_pair_of_points.cpp}

\section{Matematika}
\small
\begin{description*}
  \item[Vrste:] \vspace{-1ex}
    \begin{gather*}
      \sum_{i=1}^n i = \frac{n(n+1)}{2} \quad \sum_{i=1}^n i^2 = \frac{n(n+1)(2n+1)}{6} \quad
      \sum_{i=1}^n i^3 = \frac{n^2(n+1)^2}{4} \\
      \sum_{i=1}^n q^i = q \frac{q^n - 1}{q - 1} \quad \sum_{i=1}^n i q^i = \frac{n
        q^{n+2} - (n+1)q^{n+1} + q}{(q-1)^2}
    \end{gather*}
  \item[Kombinatorika:]
    \begin{gather*}
      \binom{n}{k} = \frac{n!}{k!(n-k)!} = \prod_{i=0}^{k-1} \frac{n-i}{i+1} = \binom{n-1}{k} + \binom{n-1}{k-1} \\
      C_n = \frac{1}{n+1}\binom{2n}{n} = \sum_{i=0}^{n-1}C_iC_{n-1-i} = \prod_{i=2}^n\frac{n+i}{i} = \frac{2(2n-1)}{n+1}C_{n-1} \\
      F_n = F_{n-1} + F_{n-2} = \begin{pmatrix} 1 & 1 \\ 0 & 1
      \end{pmatrix}^{n-1}_{11}\quad F_mF_n + F_{m-1}F_{n-1}  = F_{m+n-1} \quad
      F_mF_{n+1} + F_{m-1}F_n = F_{m+n}
    \end{gather*}
  \item[Številske ocene:] \mbox{} \\[12pt]
    \hspace*{-20pt}
    \begin{tabular}[h]{|c|c|c|c|c|c|c|c|} \hline
      $i$ & $2^i$ & $\log_{10}(2^i)$ & i! & $\log_{10}(i!)$ & $10^i$ \texttt{int}-ov & $C_i$ & $F_i$ \\ \hline
        1 &             2 & 0,30 & 1        &  0,00 & \unit[40]{B}    & 1       & 1 \\
        2 &             4 & 0,60 & 2        &  0,30 & \unit[400]{B}   & 2       & 1 \\
        3 &             8 & 0,90 & 6        &  0,77 & \unit[3,9]{kiB} & 5       & 2 \\
        4 &            16 & 1,20 & 24       &  1,38 & \unit[39]{kiB}  & 14      & 3 \\
        5 &            32 & 1,50 & 120      &  2,07 & \unit[400]{kiB} & 42      & 5 \\
        6 &            64 & 1,80 & 720      &  2,85 & \unit[3,8]{MiB} & 132     & 8 \\
        7 &           128 & 2,10 & 5040     &  3,70 & \unit[38]{MiB}  & 429     & 13 \\
        8 &           256 & 2,40 & 40320    &  4,60 & \unit[380]{MiB} & 1430    & 21 \\
        9 &           512 & 2,70 & 362880   &  5,55 & \unit[3,7]{GiB} & 4862    & 34 \\
       10 &         1.024 & 3,01 & 3628800  &  6,55 & $\cdot$         & 16796   & 55 \\
       11 &         2.048 & 3,31 & 39916800 &  7,60 & $\cdot$         & 58786   & 89 \\
       12 &         4.096 & 3,61 & $\cdot$  &  8,68 & $\cdot$         & 208012  & 144 \\
       13 &         8.192 & 3,91 & $\cdot$  &  9,79 &                 & 742900  & 233 \\
       14 &        16.384 & 4,21 & $\cdot$  & 10,94 &                 & 2674440 & 377 \\
       15 &        32.768 & 4,51 &          & 12,11 &                 & 9694845 & 610 \\
       16 &        65.536 & 4,81 &          & 13,32 &                 & $\cdot$ & 987 \\
       17 &       131.072 & 5,11 &          & 14,55 &                 & $\cdot$ & 1597 \\
       18 &       262.144 & 5,41 &          & 15,80 &                 & $\cdot$ & 2584 \\
       19 &       524.288 & 5,71 &          & 17,08 &                 &         & 4181 \\
       20 &     1.048.576 & 6,02 &          & 18,38 &                 &         & 6765 \\
       21 &     2.097.152 & 6,32 &          & 19,70 &                 &         & 10946 \\
       22 &     4.194.304 & 6,62 &          & 21,05 &                 &         & 17711 \\
       23 &     8.388.608 & 6,92 &          & 22,41 &                 &         & 28657 \\
       24 &    16.777.216 & 7,22 &          & 23,79 &                 &         & 46368 \\
       25 &    33.554.432 & 7,52 &          & 25,19 &                 &         & 75025 \\
       26 &    67.108.864 & 7,82 &          & 26,60 &                 &         & 121393 \\
       27 &   134.217.728 & 8,12 &          & 28,03 &                 &         & 196418 \\
       28 &   268.435.456 & 8,42 &          & 29,48 &                 &         & 317811 \\
       29 &   536.870.912 & 8,72 &          & 30,94 &                 &         & 514229 \\
       30 & 1.073.741.824 & 9,03 &          & 32,42 &                 &         & 832040 \\
       31 & 2.147.483.648 & 9,33 &          & 33,91 &                 &         & 1346269 \\
       32 & 4.294.967.296 & 9,63 &          & 35,42 &                 &         & 2178309 \\
       64 &              & 19,26 &          & 89,10 & Google          &         &  \\
    \end{tabular} \\[12pt]
  \item[Pascalov trikotnik:] \mbox{} \\[12pt]
    \tabcolsep=0.03cm
    \hspace*{-20pt}
    \begin{tabular}{rccccccccccccccccccccccccccccccc}
     0:~~&    &    &    &    &    &    &    &    &    &    &    &    &    &    &    &  1\\
     1:~~&    &    &    &    &    &    &    &    &    &    &    &    &    &    &  1 &    &  1\\
     2:~~&    &    &    &    &    &    &    &    &    &    &    &    &    &  1 &    &  2 &    &  1\\
     3:~~&    &    &    &    &    &    &    &    &    &    &    &    &  1 &    &  3 &    &  3 &    &  1\\
     4:~~&    &    &    &    &    &    &    &    &    &    &    &  1 &    &  4 &    &  6 &    &  4 &    &  1\\
     5:~~&    &    &    &    &    &    &    &    &    &    &  1 &    &  5 &    & 10 &    & 10 &    &  5 &    &  1\\
     6:~~&    &    &    &    &    &    &    &    &    &  1 &    &  6 &    & 15 &    & 20 &    & 15 &    &  6 &    &  1\\
     7:~~&    &    &    &    &    &    &    &    &  1 &    &  7 &    & 21 &    & 35 &    & 35 &    & 21 &    &  7 &    &  1\\
     8:~~&    &    &    &    &    &    &    &  1 &    &  8 &    & 28 &    & 56 &    & 70 &    & 56 &    & 28 &    &  8 &    &  1\\
     9:~~&    &    &    &    &    &    &  1 &    &  9 &    & 36 &    & 84 &    & 126 &    & 126 &    & 84 &    & 36 &    &  9 &    &  1\\
    10:~~&    &    &    &    &    &  1 &    & 10 &    & 45 &    & 120 &    & 210 &    & 252 &    & 210 &    & 120 &    & 45 &    & 10 &    &  1\\
    11:~~&    &    &    &    &  1 &    & 11 &    & 55 &    & 165 &    & 330 &    & 462 &    & 462 &    & 330 &    & 165 &    & 55 &    & 11 &    &  1\\
    12:~~&    &    &    &  1 &    & 12 &    & 66 &    & 220 &    & 495 &    & 792 &    & 924 &    & 792 &    & 495 &    & 220 &    & 66 &    & 12 &    &  1\\
    13:~~&    &    &  1 &    & 13 &    & 78 &    & 286 &    & 715 &    & 1287 &    & 1716 &    & 1716 &    & 1287 &    & 715 &    & 286 &    & 78 &    & 13 &    &  1\\
    \end{tabular}
\end{description*}

\end{document}
% vim: spell spelllang=sl
% vim: foldlevel=99
